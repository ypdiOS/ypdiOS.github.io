{"meta":{"title":"Coder在嘉陵江边","subtitle":"","description":"","author":"ypdiOS","url":"http://example.com","root":"/"},"pages":[{"title":"About","date":"2022-03-10T14:24:21.076Z","updated":"2022-03-10T14:24:21.076Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-03-10T14:24:21.076Z","updated":"2022-03-10T14:24:21.076Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2022-03-10T14:24:21.076Z","updated":"2022-03-10T14:24:21.076Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"光辉岁月","slug":"生活学习/光辉岁月","date":"2022-03-10T14:24:21.023Z","updated":"2022-03-10T14:24:21.023Z","comments":true,"path":"2022/03/10/生活学习/光辉岁月/","link":"","permalink":"http://example.com/2022/03/10/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E5%85%89%E8%BE%89%E5%B2%81%E6%9C%88/","excerpt":"","text":"作者：悦派对iOS 2018 2019 2022","categories":[{"name":"生活学习","slug":"生活学习","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"画中画","slug":"技术开发/画中画功能实现-doc","date":"2022-03-10T14:24:21.022Z","updated":"2022-03-10T14:24:21.022Z","comments":true,"path":"2022/03/10/技术开发/画中画功能实现-doc/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E7%94%BB%E4%B8%AD%E7%94%BB%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-doc/","excerpt":"","text":"作者：陈果 1.开启后台模式 2.导入框架#import &lt;AVKit/AVKit.h&gt; 创建AVPictureInPictureController 注：如果是使用系统播放器AVPlayerViewController，设置allowsPictureInPicturePlayback = YES即可 12345678910111213//1.判断是否支持画中画功能if ([AVPictureInPictureController isPictureInPictureSupported]) &#123; //2.开启权限 @try &#123; NSError *error = nil; [[AVAudioSession sharedInstance] setCategory:AVAudioSessionOrientationBack error:&amp;error]; [[AVAudioSession sharedInstance] setActive:YES error:&amp;error]; &#125; @catch (NSException *exception) &#123; NSLog(@&quot;AVAudioSession发生错误&quot;); &#125; self.pipVC = [[AVPictureInPictureController alloc] initWithPlayerLayer:self.player]; self.pipVC.delegate = self;&#125; 3.开启或关闭画中画 12345if (self.pipVC.isPictureInPictureActive) &#123; [self.pipVC stopPictureInPicture];&#125; else &#123; [self.pipVC startPictureInPicture];&#125; 4.代理 AVPictureInPictureControllerDelegate 123456789101112// 即将开启画中画- (void)pictureInPictureControllerWillStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController;// 已经开启画中画- (void)pictureInPictureControllerDidStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController;// 开启画中画失败- (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController failedToStartPictureInPictureWithError:(NSError *)error;// 即将关闭画中画- (void)pictureInPictureControllerWillStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController;// 已经关闭画中画- (void)pictureInPictureControllerDidStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController;// 关闭画中画且恢复播放界面- (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL restored))completionHandler; 值得注意的是，关闭画中画会执行 pictureInPictureController:restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: 这个代理方法，用来恢复播放界面的 全局画中画注意点 通过一个全局变量持有画中画控制器，可以在pictureInPictureControllerWillStartPictureInPicture持有，pictureInPictureControllerDidStopPictureInPicture释放； 有可能不是点画中画按钮，而是从其它途径来打开当前画中画控制器，可以在viewWillAppear 进行判断并关闭； 已有画中画的情况下开启新的画中画，需要等完全关闭完再开启新的，防止有未知的错误出现，因为关闭画中画是有过程的； 如果创建AVPictureInPictureController并同时开启画中画功能，有可能会失效，出现这种情况延迟开启画中画功能即可。 如需在退到后台直接就显示画中画，需要在AVPlayer play时初始化AVPlayerViewController来持有playerLayer。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"数据库(WCDB)应用","slug":"技术开发/WCDB-doc","date":"2022-03-10T14:24:21.020Z","updated":"2022-03-10T14:24:21.020Z","comments":true,"path":"2022/03/10/技术开发/WCDB-doc/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/WCDB-doc/","excerpt":"","text":"作者：陈果 [toc] 1.简介WCDB（wechat dataBase）是一个高效、完整、易用的开源移动数据库框架，基于SQLite 和 SQLCipher ，支持iOS， macOS和Android。 性能： 2.模型绑定 WCDB 基于 Swift 4.0 的 Codable 协议实现模型绑定的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// 学生表class Student: TableCodable &#123; var identifier: Int? = nil //主键 var name: String? = nil //名称 var age: Int? //年级 var sex: Int? = 0 //性别 var teacherId: String? //外键，老师的id（表示一个老师可以对应多个学生） /// 主键需要自增长时需要isAutoIncrement设成true，这样就可以实现主键自增长，不用手动赋值 var isAutoIncrement: Bool &#123; true &#125; /// 需要实现CodingKeys枚举，枚举与字段需一一对应 enum CodingKeys: String, CodingTableKey &#123; typealias Root = Student static let objectRelationalMapping = TableBinding(CodingKeys.self) case identifier = &quot;id&quot; //表示改字段在数据库表中是id，如和数据库表中保持一致就可以不赋值 case name case age case sex case teacherId /// 对应字段的是否主键，是否可空，是否自增长，是否唯一标识等约束控制 static var columnConstraintBindings: [Student.CodingKeys : ColumnConstraintBinding]? &#123; [identifier: ColumnConstraintBinding(isPrimary: true, isNotNull: true), sex: ColumnConstraintBinding(isNotNull: true, defaultTo: 0)] &#125; /// 对应字段的外键 static var tableConstraintBindings: [String : TableConstraintBinding]? &#123; let forkey = ForeignKeyBinding(teacherId, foreignKey: ForeignKey(withForeignTable: &quot;Teacher&quot;, and: [Teacher.CodingKeys.identifier])) return [&quot;ForkeyConstraint&quot;: forkey] &#125; &#125;&#125;class Teacher: TableCodable &#123; var identifier: Int? = nil var name: String? = nil var age: Int? var sex: Int? = 1 enum CodingKeys: String, CodingTableKey &#123; typealias Root = Teacher static let objectRelationalMapping = TableBinding(CodingKeys.self) case identifier case name case age case sex static var columnConstraintBindings: [Teacher.CodingKeys : ColumnConstraintBinding]? &#123; [identifier: ColumnConstraintBinding(isPrimary: true, isNotNull: true), sex: ColumnConstraintBinding(isNotNull: true, defaultTo: 1)] &#125; &#125; &#125; 3.创建数据库12345678let path = &quot;\\(NSHomeDirectory())/tmp/school.db&quot;//创建数据库let db = Database(withPath: path)//设置标签，可以通过标签获取到数据库db.tag = 1// let tempDB = Database(withExistingTag: 1)//设置了标签后，可以通过tag获取数据库//数据库加密db.setCipher(key: &quot;123456&quot;.data(using: .utf8)) 4.创建表123//创建表try? db.create(table: &quot;Student&quot;, of: Student.self)try? db.create(table: &quot;Teacher&quot;, of: Teacher.self) 5.插入数据1234567891011121314151617181920212223242526272829303132let aTeacher = Teacher()aTeacher.identifier = 123aTeacher.age = 25aTeacher.name = &quot;teacher&quot; let aStudent = Student()aStudent.identifier = 1aStudent.name = &quot;a&quot;aStudent.age = 5aStudent.sex = 0aStudent.teacherId = aTeacher.identifier let bStudent = Student()bStudent.identifier = 2bStudent.name = &quot;b&quot;bStudent.age = 6bStudent.sex = 1bStudent.teacherId = aTeacher.identifier let cStudent = Student()cStudent.identifier = 3cStudent.name = &quot;c&quot;cStudent.age = 5cStudent.teacherId = aTeacher.identifier/// 事务插入try? db.run(transaction: &#123; try? db.insert(objects: [aTeacher], intoTable: &quot;Teacher&quot;) try? db.insert(objects: [aStudent], intoTable: &quot;Student&quot;) try? db.insert(objects: [bStudent], intoTable: &quot;Student&quot;) try? db.insert(objects: [cStudent], intoTable: &quot;Student&quot;)&#125;) 6.删除数据12345678// 事务删除try? db.run(transaction: &#123; // 删除指定identifier数据 try? db.delete(fromTable: &quot;Student&quot;, where: Student.CodingKeys.identifier == 3) // 清空表 try? db.delete(fromTable: &quot;Teacher&quot;) try? db.delete(fromTable: &quot;Student&quot;)&#125;) 7.更新数据123456// 事务更新try? db.run(transaction: &#123; let dStudent = Student() dStudent.name = &quot;d&quot; try? db.update(table: &quot;Student&quot;, on: [Student.CodingKeys.name], with: dStudent, where: Student.CodingKeys.identifier == 3)&#125;) 8.查询数据12345678910111213141516171819202122232425262728293031323334353637// 单表查询let sTable = try! db.getTable(named: &quot;Student&quot;, of: Student.self) // 获取一个表// 通过where在单表里面查询对应数据，// 并通过orderby排序(传Student.CodingKeys.age默认.ascending)var students = try! sTable?.getObjects(where: Student.CodingKeys.age &gt; 0, orderBy: [Student.CodingKeys.age.asOrder(by: .descending)])print(students!)// 直接查询，需要传入指定表students = try! db.getObjects(fromTable: &quot;Student&quot;, where: Student.CodingKeys.identifier == &quot;1&quot;)print(students!)// 获取整表数据let t: [Teacher] = try! db.getObjects(fromTable: &quot;Teacher&quot;)print(t)// 联表查询与多线程DispatchQueue.global().async &#123; // on: 需要查询的字段（注意需要在多表里面字段名相同的在字段后面加in(table:表名)） let a = try! db.prepareMultiSelect(on: Teacher.CodingKeys.name.in(table: &quot;Student&quot;) ,Student.CodingKeys.age.in(table: &quot;Student&quot;), Teacher.CodingKeys.name.in(table: &quot;Teacher&quot;), fromTables: [&quot;Student&quot;, &quot;Teacher&quot;]) // 加where条件语句 a.where(Student.CodingKeys.teacherId.in(table: &quot;Student&quot;) == Teacher.CodingKeys.identifier.in(table: &quot;Teacher&quot;)/* &amp;&amp; Student.CodingKeys.identifier.in(table: &quot;Student&quot;) == &quot;2&quot;*/) // 加orderby条件语句 a.order(by: [Student.CodingKeys.age.in(table: &quot;Student&quot;).asOrder(by: .descending)]) // 逐条获取数据 while let b = try? a.nextMultiObject() &#123; print(b) &#125; // 获取所有数据// let all = try! a.allMultiObjects()// DispatchQueue.main.async &#123;// print(all)// &#125;&#125; 9.详细文档查看","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"Swift 异步特性","slug":"技术开发/Swift 异步特性-doc","date":"2022-03-10T14:24:21.019Z","updated":"2022-03-10T14:24:21.020Z","comments":true,"path":"2022/03/10/技术开发/Swift 异步特性-doc/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Swift%20%E5%BC%82%E6%AD%A5%E7%89%B9%E6%80%A7-doc/","excerpt":"","text":"作者：熊甫荣 [toc] 异步函数 Swift has built-in support for writing asynchronous and parallel code in a structured way. … the term concurrency to refer to this common combination of asynchronous and parallel code. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swift官方文档是这样描述Swift并发的，它指的就是异步和并行代码的组合。并行编程需要解决的主要问题： 如何确保不同运算运行步骤间的交互或是通信按照正确的顺序执行 如何确保运算资源在不同运算之间被安全地共享和访问 为了更容易和更优雅的解决上面两个问题，在Swift5.5中，引入了异步函数的概念。在函数声明的返回箭头前面，加上async关键字，就可以把一个函数声明为异步函数： 123func loadSignature() async -&gt; String &#123; fatalError(&quot;暂未实现&quot;)&#125; async关键字会帮助编译器做两件事情： 它允许我们在函数体内部使用await关键字； 它要求其他人在调用这个函数时，使用await关键字。 代码举例需求：从服务器拉取100000条天气数据，求取这些数据的平均值，然后将平均值回传给服务器。 分析：请求服务器的操作都是异步的毋庸置疑，由于数据量过大，求取平均值是个耗时操作，也应该异步处理。 常规代码实现： 1234567891011121314151617181920212223func fetchWeatherHistory(completion: @escaping ([Double]) -&gt; Void) &#123; // 用随机值来取代网络请求返回的数据 DispatchQueue.global().async &#123; let results = (1...100_000).map &#123; _ in Double.random(in: -10...30) &#125; completion(results) &#125;&#125;func calculateAverageTemperature(for records: [Double], completion: @escaping (Double) -&gt; Void) &#123; // 先求和再计算平均值 DispatchQueue.global().async &#123; let total = records.reduce(0, +) let average = total / Double(records.count) completion(average) &#125;&#125;func upload(result: Double, completion: @escaping (String) -&gt; Void) &#123; // 省略上传的网络请求代码，均返回&quot;OK&quot; DispatchQueue.global().async &#123; completion(&quot;OK&quot;) &#125;&#125; 调用实现 1234567fetchWeatherHistory &#123; [weak self] records in self?.calculateAverageTemperature(for: records) &#123; average in self?.upload(result: average) &#123; response in print(&quot;Server response: \\(response)&quot;) &#125; &#125;&#125; 存在的问题： 可能存在方法中多次调用或者忘记调用completion的情况; 闭包参数@escaping (String) -&gt; Void难以阅读; 层层嵌套的回调代码看起来很晦涩（所谓的回调地狱）; 在swift5.0添加Result类型之前，使用completion handlers返回错误很困难; async/await实现代码 12345678910111213func fetchWeatherHistory() async -&gt; [Double] &#123; (1...100_000).map &#123; _ in Double.random(in: -10...30) &#125;&#125;func calculateAverageTemperature(for records: [Double]) async -&gt; Double &#123; let total = records.reduce(0, +) let average = total / Double(records.count) return average&#125;func upload(result: Double) async -&gt; String &#123; &quot;OK&quot;&#125; 调用实现 123456func processWeather() async &#123; let records = await fetchWeatherHistory() let average = await calculateAverageTemperature(for: records) let response = await upload(result: average) print(&quot;Server response: \\(response)&quot;)&#125; 仅仅通过async关键字将函数标记为异步返回值，在调用函数前加上await关键字，让整个调用过程变得简单清晰，就像在编写同步代码一样。 调用流程对比 普通函数的调用流程：(如上图) 调用函数; 函数获取线程的控制权，并完全占有该线程; 函数执行完成返回或者抛出错误，将控制权交还调用方; 这里普通函数放弃线程控制权的唯一方式就是执行完成。 异步函数的调用流程：（如上图） 调用函数; 函数获得线程控制权; 函数运行后，挂起，同时放弃对线程的控制，并将控制权交给系统，系统可自由支配该线程; 系统确定何时恢复函数; 函数恢复后重新获得控制权，并继续工作; 函数执行完成或抛出异常后，返回调用方，将控制权交还给调用方; 这里需要注意几点： 一个异步函数挂起时，也会挂起它的调用者，所以调用者也必须是异步的; 异步函数可以多次挂起; 异步函数挂起时，不会阻塞线程; 异步函数可能会在一个完全不同的线程上恢复; async 函数并不一定会挂起; 异步属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Swift5.5中，升级了只读属性，以单独或一起支持async和throws关键字，使它们更灵活。 123456789101112131415161718192021enum FileError: Error &#123; case missing, unreadable&#125;struct BundleFile &#123; let filename: String var contents: String &#123; get async throws &#123; guard let url = Bundle.main.url(forResource: filename, withExtension: nil) else &#123; throw FileError.missing &#125; do &#123; return try String(contentsOf: url) &#125; catch &#123; throw FileError.unreadable &#125; &#125; &#125;&#125; 因为contents属性同时是async和throws，读取时必须使用try await: 1234func printHighScores() async throws &#123; let file = BundleFile(filename: &quot;highscores&quot;) try await print(file.contents)&#125; 注意点： 异步属性必须是只读的，可写属性不能声明为异步属性; 异步属性需要有一个明确的getter，async关键字位于get后; 从Swift 5.5 开始，getter也可以抛出异常，如果同时是异步的，则async关键字位于 throws前面; await可用于属性body中的表达式，以表明操作的异步性; 结构化并发对于同步函数来说，线程决定了它的执行环境。而对于异步函数，则由任务(Task)决定执行环境。Swift提供了一系列Task相关API来让开发者创建、组织、检查和取消任务。这些API围绕着Task这一核心类型，为每一组并发任务构建出一棵结构化的任务树： 一个任务具有它自己的优先级和取消标识，它可以拥有若干个子任务并在其中执行异步函数。 当一个父任务被取消时，这个父任务的取消标识将被设置，并向下传递到所有的子任务中去。 无论是正常完成还是抛出错误，子任务会将结果向上报告给父任务，在所有子任务正常完成之前或者有子任务抛出之前，父任务是不会被完成的。 这些特性看上去和Operation类有一些相似，不过Task直接利用异步函数的语法，可以用更简洁的方式进行表达。而Operation则需要依靠子类或者闭包。 在调用异步函数时，需要在它前面添加await关键字；而另一方面，只有在异步函数中，我们才能使用 await关键字。那么问题在于，第一个异步函数执行的上下文，或者说任务树的根节点，是怎么来的？ 简单地使用Task.init就可以让我们获取一个任务执行的上下文环境，它接受一个async标记的闭包： 123456struct Task&lt;Success, Failure&gt; where Failure : Error &#123; init( priority: TaskPriority? = nil, operation: @escaping @Sendable () async throws -&gt; Success )&#125; 它继承当前任务上下文的优先级等特性，创建一个新的任务树根节点，我们可以在其中使用异步函数： 12345678910111213141516171819var results: [String] = []func someSyncMethod() &#123; Task &#123; try await processFromScratch() print(&quot;Done: \\(results)&quot;) &#125;&#125;func processFromScratch() async throws &#123; let strings = await loadFromDatabase() if let signature = try await loadSignature() &#123; strings.forEach &#123; results.append($0.appending(signature)) &#125; &#125; else &#123; //throw error &#125;&#125; processFromScratch中的处理依然是串行的：对loadFromDatabase的await将使这个异步函数在此暂停，直到实际操作结束，接下来才会执行loadSignature： 我们当然会希望这两个操作可以同时进行，同时，只有当两者都准备好后，才能调用appending来实际将签名附加到数据上。这需要任务以结构化的方式进行组织。使用async let绑定可以做到这一点： 12345678910111213func processFromScratchNew() async throws &#123;//结构化并发 async let loadStrings = loadFromDatabase() async let loadSignature = loadSignature() let strings = await loadStrings if let signature = try await loadSignature &#123; strings.forEach &#123; results.append($0.appending(signature)) &#125; &#125; else &#123; //throw error &#125;&#125; async let被称为异步绑定，它在当前Task上下文中创建新的子任务，并将它用作被绑定的异步函数的运行环境。和Task.init新建一个任务根节点不同，async let所创建的子任务是任务树上的叶子节点，它是结构化的。被异步绑定的操作会立即开始执行，即使在await之前执行就已经完成，其结果依然可以等到 await语句时再进行求值。在上面的例子中，loadFromDatabase和loadSignature将被并发执行。 除了async let外，另一种创建结构化并发的方式，是使用任务组(Task group)。比如，我们希望在执行 loadResultRemotely的同时，让processFromScratch一起运行，可以将两个操作写在同一个task group中： 12345678910111213func someSyncMethod() &#123; Task &#123; await withThrowingTaskGroup(of: Void.self) &#123; group in group.async &#123; try await self.loadResultRemotely() &#125; group.async &#123; try await self.processFromScratch() &#125; &#125; print(&quot;Done: \\(results)&quot;) &#125;&#125; 演员模型Swift5.5引入了actor，在概念上类似于在并发环境中可以安全使用的类，即需要确保在任何时间只能由单个线程访问actor内的可变状态。 代码演示：创建一个RiskyCollector类，该类能够实现两个收集器对象之间交换牌组中的卡片。 12345678910111213141516171819class RiskyCollector &#123; var deck: Set&lt;String&gt; init(deck: Set&lt;String&gt;) &#123; self.deck = deck &#125; func send(card selected: String, to person: RiskyCollector) -&gt; Bool &#123; guard deck.contains(selected) else &#123; return false &#125; deck.remove(selected) person.transfer(card: selected) return true &#125; func transfer(card: String) &#123; deck.insert(card) &#125;&#125; 在单线程中，代码是安全的，但是在多线程中就不安全了，如果我们同时调用send(card:to:)多次，可能会发生以下事件链： 第一个线程检查卡片是否在牌组中，并且是这样继续。 第二个线程还检查卡片是否在牌组中，并且是这样继续。 第一个线程从牌组中取出卡片并将其转移给另一个人。 第二个线程试图从牌组中取出这张牌，但实际上它已经消失了，所以什么也不会发生。但是，它仍然将卡转让给其他人。 在这种情况下，一个玩家失去1张牌，而另一个玩家得到2张牌，这显然是不合理的。通过actor模型可以解决这个问题：除非异步执行，否则无法从Actor对象外部读取存储的属性和方法，并且根本无法从 Actor 对象外部写入存储的属性。异步行为不是为了性能；相反，这是因为Swift会自动将这些请求放入一个按顺序处理的队列中，以避免出现竞争条件。因此，我们可以将RiskyCollector类重写为SafeCollector actor,如下所示： 12345678910111213141516171819actor SafeCollector &#123; var deck: Set&lt;String&gt; init(deck: Set&lt;String&gt;) &#123; self.deck = deck &#125; func send(card selected: String, to person: SafeCollector) async -&gt; Bool &#123; guard deck.contains(selected) else &#123; return false &#125; deck.remove(selected) await person.transfer(card: selected) return true &#125; func transfer(card: String) &#123; deck.insert(card) &#125;&#125; 注意点： Actor是使用actor关键字创建的。这是Swift中一种新的具体名义类型，用于连接结构体、类和枚举。 该send()方法标有async，因为它需要在等待传输完成时暂停其工作。 虽然该transfer(card:)方法没有用标记async，但我们仍然需要用await来调用它，因为它会等到另一个SafeCollector actor能够处理请求。 需要明确的是，actor可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的actor交互时，它必须始终异步完成。通过这些更改，Swift可以确保永远不会同时访问所有与actor隔离的状态，更重要的是，这是在编译时完成的，以保证安全。 Actor和类的对比，相同点： 两者都是引用类型，因此它们可用于共享状态。 它们可以有方法、属性、初始值设定项和下标。 它们可以符合协议并且是通用的。 任何静态属性和方法在这两种类型中的行为都相同，因为它们没有self的概念，因此不会被隔离。 区别： Actors 目前不支持继承。 Actors 遵循新的Actor协议。 总结Swift并发的概念很多，但是各种的模块边界是清晰的： 异步函数：提供语法工具，使用更简洁和高效的方式，表达异步行为。 结构化并发：提供并发的运行环境，负责高效的异步函数调度、取消和执行顺序。 演员模型：提供封装良好的数据隔离，确保并发代码的安全。 熟悉这些边界，有助于我们清晰地理解 Swift 并发各个部分的设计意图，从而让我们手中的工具可以被运用在正确的地方。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"SiriKit 调研","slug":"技术开发/Sirikit-doc","date":"2022-03-10T14:24:21.017Z","updated":"2022-03-10T14:24:21.017Z","comments":true,"path":"2022/03/10/技术开发/Sirikit-doc/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Sirikit-doc/","excerpt":"","text":"作者：熊甫荣 [toc] SiriKit简介iOS 10之后，Apple开放了SiriKit框架，用于通过Siri更加方便用户操作App相关功能。 用户向Siri发送语音指令，Siri将此指令解析为Intent对象，发送给相关联的App Extentsion。Extension根据Intent执行相关操作，完成用户指令。相关操作可以通过Intent UI Extentsion展示在Siri中。 Siri将可以解析并完成的Intent划分到不同的域（domain）中，包含以下几种： 域（domain） 对应的意图（Intent） 语音和视频通话 (VoIP calling) INSearchCallHistoryIntent、INStartAudioCallIntent、INStartVideoCallIntent 发送消息 (Messaging) INSendMessageIntent 收款或者付款 (Payments) INSendPaymentIntent、INRequestPaymentIntent 列表和笔记 (Lists and Notes) INCreateNoteIntent、INAppendToNoteIntent 视觉编码 (Visual Codes) INGetVisualCodeIntent 图片搜索 (Photo search) INSearchForPhotosIntent 管理锻炼 (Workouts) INEndWorkoutIntent、INPauseWorkoutIntent 、INStartWorkoutIntent 、 INResumeWorkoutIntent 、INCancelWorkoutIntent 行程预约 (Ride booking) INRequestRideIntent、INGetRideStatusIntent、 INListRideOptionsIntent、 INGetRideStatusIntent 车载管理 (Car Commands) INGetCarLockStatusIntent、INSetCarLockStatusIntent、INActivateCarSignalIntent 车载系统 (CarPlay) INSetAudioSourceInCarIntent、 INSetClimateSettingsInCarIntent、 INSetSeatSettingsInCarIntent、INSaveProfileInCarIntent、INSetProfileInCarIntent、INSetRadioStationIntent 餐厅订位 (Restaurant Reservations) INBookRestaurantReservationIntent、 INGetAvailableRestaurantReservationBookingDefaultsIntent、 INGetAvailableRestaurantReservationBookingsIntent、 INGetRestaurantGuestIntent、 INGetUserCurrentRestaurantReservationBookingsIntent SiriKit工作流工作流如下图： 所有语音解析由Siri完成，Siri将解析后的用户指令封装为Intent对象发送给相应的App Extension程序； Intent UI Extension提供交互中展示在Siri中的UI界面，可以增强用户体验，为可选项； Siri完成语音识别和语义分析； 根据你词汇中的关键词识别出你属于上述11种域（domain）中的哪一种； 然后将结构化语音分析结果打包成一个某个域（Domain）的意图(Intent)； 接着交给支持这个意图（Intent）的第三方App Extension，App Extension启动，从传入的Intent中获取相应的信息，完成操作。 SiriKit集成1.开启Siri Capabilities。必须要有付费开发者账号，未付费开发者无此选项。 2.请求Siri权限。 1234567891011121314- (void)checkSiriAuth &#123; [INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123; switch (status) &#123; case INSiriAuthorizationStatusAuthorized: NSLog(@&quot;Siri Authorized&quot;); break; default: NSLog(@&quot;Siri Not Authorized&quot;); break; &#125; &#125;];&#125; 3.添加Intents Extension，Xcode会附带提示是否添加Intents UI Extentsion（可选） Xcode: File-&gt;New-&gt;Target… 在添加的Extension的Info.plist文件中定义好需要支持的Intent SiriKit处理流程下面以发消息INSendMessageIntent来说明： 1)、一个标准的意图语音被Siri识别之后，SiriKit会先进入一个继承于INExtension的指定意图流程入口(NSExtensionPrincipalClass)类IntentHandler.m(默认类) 方法列表 说明 -resolveRecipientsForSendMessage:withCompletion: 解析发送消息语义，提取意图对象 - resolveContentForSendMessage:withCompletion: 解析发送消息内容方法 - confirmSendMessage:completion: 确认方法 - handleSendMessage:completion: 处理方法 2）、一个典型的Intent事件的处理过程中有这三个步骤Resolve、Confirm和Handle: 1.Resolve阶段。在Siri获取到用户的语音输入之后，生成一个INIntent对象，将语音中的关键信息提取出来并且填充对应的属性。这个对象在稍后会传递给我们设置好的INExtension子类对象进行处理，根据子类遵循的不同协议来选择不同的解决方案。 2.Confirm阶段。在上一个阶段通过handlerForIntent:(INIntent *)返回了处理Intent的对象，此阶段会依次调用confirm打头的实例方法来判断Siri填充的信息是否完成。匹配的判断结果包括Exactly one match、Two or more matches以及No match三种情况。这个过程中可以让Siri向用户征求更具体的参数信息。 3.Handle阶段。在confirm方法执行完成之后，Siri进行最后的处理阶段，生成答复对象，并且向此Intent对象确认处理结果然后执显示结果给用户看。 3）、INSendMessageIntent 类介绍 属性名称 类型 备注 recipients NSArray&lt;INPerson*&gt; Contacts to whom the message should be sent. content NSString Body text of the message. groupName NSString Body text of the message. serviceName NSString Specified service for the message. sender INPerson The person, or account, sending the message. 通过流程方法里获取到INSendMessageIntent对象进行解析，匹配，处理，这个过程还涉及到返回的处理。每一个解析方法都需要得到一个INIntentResolutionResult类型的实例，用来保存校验结果。 INIntentResolutionResult及其子类有不同的构造方法生成不同类型的结果，用来指定和Siri的交互。 INIntentResolutionResult 说明 + (instancetype)needsValue 需要一个值，Siri会提示用户给一个值 + (instancetype)notRequired 不是必要的，是否给值都会过这个resolve + (instancetype)unsupported 不支持的，Siri会提示用户这个值不被支持 + (instancetype)successWithResolvedValue:(BOOL)resolvedValue 成功解析 4)、根据流程方法处理之后，如何与主程序通信 轻量级通信可采用这个办法：1）、在handling阶段在NSUserActivity存储相应的信息，字典或字符串都行（如上handling阶段代码）。2）、在AppDelegate，获取NSUserActivity所存储的信息。3）、发送通知给所需要的地方。4）、接收到通知后对主程序进行相应操作。 有关在AppDelegate中处理SiriKit的Intent可以参考苹果官方文档 1234567891011121314//AppDelegate.m- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; return NO;&#125;- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivityrestorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler &#123; if ([userActivity.interaction.intent isKindOfClass:[INSendMessageIntent class]]) &#123; INSendMessageIntent *intent = (INSendMessageIntent *)(userActivity.interaction.intent); NSLog(@&quot;%@&quot;,[[intent.recipients lastObject] displayName]); &#125; return YES;&#125; Intent UI Extension运用SiriKit开发相关功能，UI是依赖于Intent UI Extension，SiriKit并不能从系统层面调用App内部UI，只能调用打开App和SirKit自定义UI。 系统创建了ViewController，加载视图，调用viewDidLoad方法并且调用了INUIHostedViewControlling协议的configureWithInteraction:context:completion:方法，传递了一个交互对象，用于配置界面。 当配置完成后，ViewController就会展示在Siri或者Maps应用界面的空白部分。这时会调用viewWillAppear/viewDidAppear方法。当视图消失时，也会调用生命周期的viewWillDisappear/viewDidDisappear方法。 关于控制器的使用，苹果给出了几点注意事项： 切换子控制器来展示不同类型的内容。 你的Intents UI扩展只有一个主视图控制器，如果你想为不同的Intents展示不同的内容，你需要使用不同的视图。可以在configureWithInteraction:context:completion:这个方法里面，根据提供的intentObject来创建不同的子视图。 在你的视图控制器可用的期间，动态调整内容。 在viewDidAppear:方法里面才开始启动动画，在viewWillDisappear:方法里面要结束动画。 尽快的配置好你的视图控制器，这样Siri才能更快的展示它。 你的视图控制器也许不会在屏幕上停留太久，所以尽量利用本地资源以及提供的INInteraction对象来配置你的设置。如果你需要从服务器拉取更多的信息，请异步完成，并在稍后再更新你的界面。 请不要在界面里面展示广告。你可以展示你自己的品牌信息，但是你不能够加入其它广告。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"Settings.Bundle","slug":"技术开发/SettingsBundle-doc","date":"2022-03-10T14:24:21.011Z","updated":"2022-03-10T14:24:21.011Z","comments":true,"path":"2022/03/10/技术开发/SettingsBundle-doc/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/SettingsBundle-doc/","excerpt":"","text":"作者：陈果 Settings.Bundle效果图： 如何设置1.New File -&gt;Settings.Bundle 在右侧的目录会看到： 2.Settings.Bundle支持六种配置项分别是：Title，MultiValue，Group，TextField，ToggleSwitch，Slider 。 Title — 不可更改的标题 Type：配置类型，默认是TitleTitle：配置项显示的TitleIdentifier: 配置项的标识符，用来获取配置项的配置内容Default Value :配置项默认值 MultiValue — 多选 Type：配置类型，默认Multi Value Title：配置项显示的标题 Identifier：配置项标识符，用来获取配置项的配置内容 Default：配置项默认值 Titles：显示的标题数组 Values：显示的值数组，与Titles一一对应 Group — 分组 Type，Title 同上； FooterText: 底部说明 TextField — 输入框 Text Field Is Secure：是否密文显示 KeyBoard Type：键盘类型 Autocapitalization Stylele：自动大写 Autocorrection Style：自动纠正拼写 ToggleSwitch — 开关 Default Value :配置项默认值 Slider — 进度条 Minimum Value：最小值Maximun Value：最大值Min Value Image Filename：最小值端图片Max Value Image Filename：最大值端图片 注意: Image Filename 不能放在主文件夹中，而是需要放在Settings捆绑包中，才能够通过 Min/Max Value Image Filename 设置使用, 如: 程序中获取配置信息获取配置信息其实很简单，直接上代码： 1234567891011//获取SettingsBundle信息 NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; NSLog(@&quot;%@&quot;,[userDefaults objectForKey:@&quot;title_perference&quot;]); NSLog(@&quot;%@&quot;,[userDefaults objectForKey:@&quot;sex_perference&quot;]); NSLog(@&quot;%@&quot;,[userDefaults objectForKey:@&quot;name_preference&quot;]); NSLog(@&quot;%@&quot;,[userDefaults objectForKey:@&quot;enabled_preference&quot;]); NSLog(@&quot;%@&quot;,[userDefaults objectForKey:@&quot;slider_preference&quot;]);//获取后如需恢复默认 [userDefaults setObject:@(false) forKey:@&quot;enabled_preference&quot;]; [userDefaults synchronize]; 这里有一点需要说明： 如果运行应用后直接直接通过上面的代码获取信息，你会得到null；原因是： root.plist实际上只是一个静态文件用来在设置里显示；只有当你对它进行修改，它才会往NSUserDefaults里添加。修改配置后，NSUserDefaults的优先级高于root.plist文件。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"PHPicker","slug":"技术开发/PHPicker","date":"2022-03-10T14:24:21.010Z","updated":"2022-03-10T14:24:21.011Z","comments":true,"path":"2022/03/10/技术开发/PHPicker/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/PHPicker/","excerpt":"","text":"作者：易金鑫 前言 针对IOS的应用大多数都会和相册打交道，选择照片或者视频，用于设置头像，发个动态等等，但是往往用户只需要选择一张图片时，APP通过授权就能获取到用户整个相册所有照片，这对用户隐私有着严重泄漏风险，苹果一直注重用户隐私保护，所有在IOS14之后苹果在相册做了很大改变。 相册改变 1.相册权限变动：IOS14后苹果引入了一个新的权限状态：limited 当我们通过 requestAuthorization 向用户获取权限时，弹窗中多了一个选项：“选择部分照片”，此时系统会在 App 进程之外弹出相册让用户选择授权给当前 App 访问的照片。用户完成选择后，App 通过相册相关的 api 就只能获取到指定的这几张照片，这有效的保护了用户的隐私，这个设计虽然保护了用户的隐私，但是从 App 的角度来看却引入了新的问题：如果我们还是用原先的那一套流程来获取照片，那么在用户选择了部分权限的情况下，每次弹出相册后用户都无法选择其他的照片，解决办法是再次弹出权限询问，让用户选择或者更换指定的照片，然后再回到我们的相册 UI，这一套流程明显更加复杂，降低了用户体验。 2.新的相册组件：PHPicker 是 iOS 14 引入的一套全新的相册 API，通过它访问相册，可以不需要向用户获取相关权限，而且具有与系统相册一致的 UI 和操作方式，可以保证用户体验的一致性。并且和相册 App 一样，支持通过人物、地点等关键信息来搜索照片。并且 PHPicker 是在独立进程中运行的，与宿主 App 无关，宿主 App 也无法通过截屏 api 来获取当前屏幕上的照片信息（这篇文章主要就是说这个）。 PHPicker 使用 1.声明 PHPickerConfiguration，进行配置，再传给 PHPickerViewController，完成调用环节，代码如下： var config = PHPickerConfiguration()// 可选择的资源数量，0表示不设限制，默认为1config.selectionLimit = 0// 可选择的资源类型// 只显示图片（注：images 包含 livePhotos）config.filter = .images// 显示 Live Photos 和视频（注：livePhotos 不包含 images）config.filter = .any(of: [.livePhotos, .videos])// 如果要获取视频，最好设置该属性，避免系统对视频进行转码config.preferredAssetRepresentationMode = .current let picker = PHPickerViewController(configuration: config)picker.delegate = selfpresent(picker, animated: true, completion: nil) 2.处理 PHPicker 的回调 PHPicker 的代理方法只有一个（注意： 取消选择也会触发代理方法，会返回空的 results），声明如下： @available(iOS 14, *)public protocol PHPickerViewControllerDelegate : AnyObject { func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult])} 3.如何获取照片？ 获取照片比较简单，通过 NSItemProvider 的 loadObject 方法，并且指定 Class 类型为 UIImage，就可以在回调中得到 UIImage 类型的照片了（获取 LivePhoto 与获取照片类似，只是需要将 UIImage 替换为 PHLivePhoto。之后你可以通过 PHLivePhotoView 来显示。或者通过 PHAssetResourceManager 获取 LivePhoto 的原始数据）代码如下： func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) { // 首先需要 dismiss picker picker.dismiss(animated: true, completion: nil) for result in results { // 判断类型是否为 UIImage if result.itemProvider.canLoadObject(ofClass: UIImage.self) { // 确认类型后，调用 loadObject 方法获取图片 result.itemProvider.loadObject(ofClass: UIImage.self) { (data, error) in // 回调结果是在异步线程，展示时需要切换到主线程 if let image = data as? UIImage { DispatchQueue.main.async { self.showImage(image) } } } } }} 4.如何获取视频？获取视频稍微复杂一点，框架开发者在官方论坛中明确指出需要使用 loadFileRepresentation 方法来加载大文件，loadFileRepresentation 的使用方式与 UIImage 类似，但需要额外传入一个参数 forTypeIdentifier 来指定文件类型，指定为 public.movie 可以覆盖相册中的 .mov 和 .mp4 类型。与照片不同的是，这个 api 返回的是一个 URL 类型的临时文件路径，苹果在这个 API 的说明中指出：系统会把请求的文件数据复制到这个路径对应的地址，并且在回调执行完毕后删除临时文件。代码如下： func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) { // 首先需要 dismiss picker picker.dismiss(animated: true, completion: nil) for result in results { if result.itemProvider.canLoadObject(ofClass: UIImage.self) { // 判断类型是否为 UIImage … } else { // 类型为 Video // 调用 loadFileRepresentation 方法获取视频的 url // 这里 Type Identifier 我们用 UTType.movie.identifier (“public.movie”) 这个 UTI 可以获取所有格式的视频 result.itemProvider.loadFileRepresentation(forTypeIdentifier: UTType.movie.identifier) { (url, error) in if let error = error { print(error) return } // 系统会将视频文件存放到 tmp 文件夹下 // 我们必须在这个回调结束前，将视频拷贝出去，一旦回调结束，系统就会把视频删掉 // 所以一定要确定拷贝结束后，再切换到主线程做 UI 操作 // 另外不用担心视频过大而导致拷贝的时间很久，系统将创建一个 APFS 的克隆项，因此拷贝的速度会非常快 guard let url = url else { return } let fileName = “(Int(Date().timeIntervalSince1970)).(url.pathExtension)” let newUrl = URL(fileURLWithPath: NSTemporaryDirectory() + fileName) try? FileManager.default.copyItem(at: url, to: newUrl) DispatchQueue.main.async { self.playVideo(newUrl) } } } }} iCloud同步 iOS 相册提供了 iCloud 同步功能，如果用户开启了相册同步，那么相册中的照片、视频或者 LivePhoto 有可能会被上传到 iCloud，而本地只保存有缩略图，当请求某张照片时，相册会先从 iCloud 下载，然后再返回数据。 在以前具有完整访问权限时，App 可以获得资源是否存在 iCloud 的状态，并且在下载时获得进度信息。由于 PHPicker 向 App 隐藏了所有隐私信息，因此我们无法再得知资源的 iCloud 同步状态，PHPicker 会自动从 iCloud 下载资源，并且完成之后通过 delegate 回调将数据返回，但是宿主 App 是无法从 PHPicker 中获取到 iCloud 的下载进度信息的，所以暴露出一个问题就是如果用户选择了比较大的视频，或者是网络状态不好的话，视频导出依然需要耗费非常长的时间，并且没有进度信息！ 总结PHPicker 的集成本身很简单，也存在一定的优缺点:优点： 保护用户隐私不需要频繁询问相册权限 对于用户体验提升较大 行为逻辑与系统相册保持一致，降低了用户的学习成本 集成简单，在最低支持版本 iOS 14缺点： 太过简单，选择的图片没有进行编辑，选择视频也没有时长限制， iCloud 大文件下载缺少进度信息相当于加载一个文件不知道什么时候能结束，没有用户体验。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"iMessage调研","slug":"技术开发/IMessage调研-doc","date":"2022-03-10T14:24:21.009Z","updated":"2022-03-10T14:24:21.009Z","comments":true,"path":"2022/03/10/技术开发/IMessage调研-doc/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/IMessage%E8%B0%83%E7%A0%94-doc/","excerpt":"","text":"作者：魏乔森 前言：iMessage App：和IOS App一样是一个独立运行的项目，区别在于其上架的商店为iMessage AppStore（内置于系统的iMessage应用内），所以其开发流程和IOS App开发一样会有上架审核流程iMessage App上架相关配置参考 开发模式：有单独建立项目和在宿主App内新建iMessage Extension两种开发方式，两种开发方式共同点是审核流程一致，区别在于第一种方式上架后需要单独到iMessage AppStore下载才能使用，后一种方式会跟随宿主App自动下载，基于此次调研目的主要是为了对宿主App做辅助推广，所以调研只针对后一种开发模式做文档描述Demo地址：ios项目Party的Develop_iMessage分支（git地址：https://gitlab.haochang.tv/iOS/party.git）一、创建Extension打开需要创建iMessage Extension的项目App-&gt;选中File-&gt;New-&gt;Target-&gt;iMessage Extension 创建好iMessage Extension后即可进行界面功能开发，示例中Extension命名为ChunKMessage，其结构如下： 补充说明：Extension刚创建时无相关资源文件，只有一个MessagesViewController.swift类文件 二、消息发送：2.1 文本消息123activeConversation?.insertText(&quot;测试&quot;, completionHandler: &#123; (error) in print(error ?? &quot;error&quot;)&#125;) 2.2 图片消息123456789//需要使用本地图片guard let url = Bundle.main.url(forResource: &quot;image&quot;, withExtension: &quot;jpeg&quot;) else &#123; return&#125;requestPresentationStyle(.compact)activeConversation?.insertAttachment(url, withAlternateFilename: nil, completionHandler: &#123; (error) in print(error ?? &quot;error&quot;)&#125;) 2.3 音频消息123456789//需要使用本地音频guard let url = Bundle.main.url(forResource: &quot;audio&quot;, withExtension: &quot;m4a&quot;) else &#123; return&#125;requestPresentationStyle(.compact)activeConversation?.insertAttachment(url, withAlternateFilename: nil, completionHandler: &#123; (error) in print(error ?? &quot;error&quot;)&#125;) 2.4 视频消息123456789//需要使用本地视频guard let url = Bundle.main.url(forResource: &quot;video&quot;, withExtension: &quot;mp4&quot;) else &#123; return&#125;requestPresentationStyle(.compact)activeConversation?.insertAttachment(url, withAlternateFilename: nil, completionHandler: &#123; (error) in print(error ?? &quot;error&quot;)&#125;) 2.5 贴纸消息12345678910111213141516171819//需要使用本地图片requestPresentationStyle(.compact)guard let url = Bundle.main.url(forResource: &quot;1&quot;, withExtension: &quot;gif&quot;) else &#123; return&#125;var localSticker:MSSticker?do &#123; localSticker = try MSSticker(contentsOfFileURL: url, localizedDescription: &quot;localizedDescription&quot;)&#125; catch &#123; localSticker = nil&#125;guard let sticker = localSticker else &#123; return&#125;activeConversation?.insert(sticker, completionHandler: &#123; (error) in print(error ?? &quot;error&quot;)&#125;) 2.6 发送自定义消息12345678910111213requestPresentationStyle(.compact)let layout = MSMessageTemplateLayout()if let data = NSData(contentsOf: URL(string: &quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb1-q.mafengwo.net%2Fs7%2FM00%2F2E%2F37%2FwKgB6lSuHraAYMNtAAXF8ovILuk683.png&amp;refer=http%3A%2F%2Fb1-q.mafengwo.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1628742982&amp;t=e19895ea719bc7207062eae6d07a42dc&quot;) ?? URL(fileURLWithPath: &quot;&quot;)) &#123; layout.image = UIImage(data: data as Data)&#125;layout.caption = &quot;测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本测试文本&quot;let message = MSMessage()message.layout = layoutactiveConversation?.insert(message, completionHandler: &#123; (error) in print(error ?? &quot;error&quot;)&#125;) 补充说明：iMessage App 有一个自带贴图展示的控件：MSStickerBrowserViewController，其用法类似iOS App的tableView，其遵循了MSStickerBrowserViewDataSource代理方法用于贴图内容展示，贴图点击后自动发送贴图消息 使用详情参考 相关类说明参考 三、与宿主App数据共享3.1 本地数据App Group：由于Extension和宿主app分属2个不同的沙盒文件区域，所以需要借助苹果的App Group配置一个共同的沙盒访问区，所有需要共同访问的文件都需要存储到对应的公共沙盒访问区 keychain：通过配置keychain-sharing来达到访问共同数据的目的 配置App Group参考 配置keychain-sharing参考 3.2 Pod文件在项目的podfile文件里面加入： 1link_with &#x27;宿主App的名字&#x27;, &#x27;拓展App的名字&#x27; 然后执行 pod update --no-repo-update 。如果你是使用了bundle，执行 bundle exec update --no-repo-update这样就在宿主App和拓展App之间的建立了pod文件的连接，此种方式会将所有的pod库文件进行链接 如果只需要链接部分库，可以这样： 123456789target &#x27;宿主App的名字&#x27; do pod ... pod ... pod ...endtarget &#x27;拓展App的名字&#x27; do pod ...end 3.3 Assets.xcassets在xcassets里面直接勾选想要共享的target就可以了 3.4 类文件如果你需要共享的文件不是太多，那就直接把相关的类文件拷贝一份到Extension当中就可以了，如果共享文件比较多，或者想要更优雅的共享文件的方式，可以通过创建一个framework来引用公共的类文件（注意：宿主app中的相关引用需要删除，然后宿主app和extension分别引入framework） 文件共享参考 四、跳转到宿主App消息点击跳转方法： 1234567891011121314151617181920override func didSelect(_ message: MSMessage, conversation: MSConversation) &#123;//在第一次点击后后续点击无效print(message.summaryText ?? &quot;&quot;)extensionContext?.open(URL(string: &quot;https://itunes.apple.com/cn/app/id1372619598?mt=8&quot;) ?? URL(fileURLWithPath: &quot;&quot;), completionHandler: &#123; (success) in&#125;)&#125;override func willBecomeActive(with conversation: MSConversation) &#123;guard let message = conversation.selectedMessage else &#123; print(&quot;无消息&quot;) return&#125;print(message.summaryText ?? &quot;&quot;)//此处URL无论内容是什么都会跳转到宿主app内，所以可以在此处做跳转到指定界面的控制extensionContext?.open(URL(string: &quot;https://itunes.apple.com/cn/app/id1372619598?mt=8&quot;) ?? URL(fileURLWithPath: &quot;&quot;), completionHandler: &#123; (success) in&#125;)&#125; 注意：didSelect第一次点击是OK的，顺利的跳转到了宿主 App，然后回来再点击不是打开宿主 App，而是打开iMessage App。通过打断点发现毫无反应。这是因为当调转到宿主 App之后iMessage App就已经退出了，此时需要在willBecomeActive或didResignActive方法中做点击相关操作 消息点击参考","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"IGListKit框架解析","slug":"技术开发/IGListKit-doc","date":"2022-03-10T14:24:21.007Z","updated":"2022-03-10T14:24:21.008Z","comments":true,"path":"2022/03/10/技术开发/IGListKit-doc/","link":"","permalink":"http://example.com/2022/03/10/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/IGListKit-doc/","excerpt":"","text":"作者：易金鑫 一、前言IGListKit这个框架是由Instagram团队开发的属于一个数据驱动的UICollectionView框架，用于构建一个快速灵活的列表控件。 二、背景做App开发过程中，一开始总是编写一些简单的页面，随着版本迭代，功能不断增加，页面越来越复杂，当功能达到一定规模，修改的效率和质量都越来越低，因为功能已经蠕变，大量视图的堆积的控制器修改起来越来越棘手，这个时候就体现了拥有一个好的架构的优势了。而IGListKit就是为这而被设计出来，下面我们简单说一说它吧。 三、IGListKit的特点：123451. 数据驱动（数据改变 -&gt; Diff算法 -&gt; update界面）2. 可重复单元和组件的更好体系结构3. 解耦的差异算法4. 可以为数据模型自定义差异算法5. 可扩展的API 四、IGListKit工作原理使用IGListKit，您可以提供要在UICollectionView中显示的对象数组。 对于每种类型的对象，适配器adapter都会创建一个节控制器(section controller)，它具有创建单元格的所有细节。 图 1-1 五、IGListKit使用1. CocoaPods1pod &#x27;IGListKit&#x27;, &#x27;~&gt; 4.0&#x27; 2. IGListAdapter初始化在控制器中布局好CollectionView之后，初始化IGListAdapter实例adapter，将CollectionView绑定给adapter，然后控制器实现adapter的DataSource协议，该协议实现为adapter提供节点数量以及对应节点的节点控制器类型。 12345678910@property (nonatomic, strong) IGListAdapter *adapter;- (void)_initAdapter &#123; /// 初始化适配器 self.adapter = [[IGListAdapter alloc] initWithUpdater:[IGListAdapterUpdater new] viewController:self workingRangeSize: 3]; /// 绑定一个适配器弱应用的UICollectionView列表对象 self.adapter.collectionView = self.collectionView; /// 指定数据源代理 self.adapter.dataSource = self;&#125; IGListAdapter初始化有三个参数: IGListAdapterUpdater: 是一个实现了IGListUpdatingDelegate协议的对象，负责处理row和section的刷新。 viewController: 是一个容纳适配器的UIViewController。 IGListKit稍后使用此视图控制器导航到其他视图控制器。 workingRangeSize：是working range的大小，允许您为可见框外部的部分准备内容，可以理解为预加载范围。 IGListAdapter的DataSource协议： 1234567891011121314/// 数据为空时，显示的空视图，默认没有- (nullable UIView *)emptyViewForListAdapter:(nonnull IGListAdapter *)listAdapter &#123; return nil;&#125;/// 节点数量- (NSArray&lt;id&lt;IGListDiffable&gt;&gt; *)objectsForListAdapter:(IGListAdapter *)listAdapter &#123; return self.dataList;&#125;/// 节点类型（可以根据不通的object 返回不同的节点类型）- (nonnull IGListSectionController *)listAdapter:(nonnull IGListAdapter *)listAdapter sectionControllerForObject:(nonnull id)object &#123; return [CKWorkRangeSection new];&#125; 3. IGListSectionController创建IGListSectionController是一个可以说是为IGListAdapter提供实际数据的节点控制器，在这个节点控制器中，持有的collectionContext是一个弱引用上下文对象，其中包含有关使用节控制器的适配器、集合视图和视图控制器的信息。而当adapter刷新到对应数据时，就会通过datasource代理找到对应的节点控制器来更新UI，IGListSectionController需要实现4个方法： 1234567891011121314151617181920212223242526272829303132/// 单元格数量- (NSInteger)numberOfItems &#123; return 2;&#125;/// 单元格大小- (CGSize)sizeForItemAtIndex:(NSInteger)index &#123; const CGFloat width = self.collectionContext.containerSize.width; const CGFloat height = index == 0 ? 250 : 30; return CGSizeMake(width, height);&#125;/// 单元格类型- (__kindof UICollectionViewCell *)cellForItemAtIndex:(NSInteger)index &#123; const Class cellClass = index == 0 ? [CKDemoImageCell class] : [CKDemoLabelCell class]; UICollectionViewCell&lt;IGListBindable&gt; *cell = [self.collectionContext dequeueReusableCellOfClass:cellClass forSectionController:self atIndex:index]; [cell bindViewModel:[self _urlString]]; return cell;&#125;/// 更新整个节点数据- (void)didUpdateToObject:(id)object &#123; if (![object isKindOfClass:[NSString class]]) &#123; return; &#125; self.object = object;&#125;/// 选中对应单元格- (void)didSelectItemAtIndex:(NSInteger)index &#123;&#125; 4. 数据模型前面提到了控制器实现了IGListAdapter的datasource方法，里面提供的数据源必须要遵循IGListDiffable协议，实现该协议的对象会有两个协议方法需要实现，这里我给NSString添加了分类，让其遵循了这个协议： 1234567891011121314#import &quot;NSString+Extension.h&quot;@implementation NSString (Extension)- (id&lt;NSObject&gt;)diffIdentifier &#123; return self;&#125;/// 差异比对 --在数据刷新是，差异算法用于比对数据对象是否是同一个- (BOOL)isEqualToDiffableObject:(id&lt;IGListDiffable&gt;)object &#123; return [self isEqual:object];&#125;@end 5. 刷新IGListAdapter提供特定的刷新方法，不在调用列表原生的系统API刷新，在数据改变后，需要界面即使刷新，调用一次就行，IGListAdapter会通过特定的差异算法进行比对之后再使得弱绑定的CollectionView刷新。该方法调用如下： 123456789- (void)_initDate &#123; [self.dataList removeAllObjects]; for (int i = 200; i &lt; 300; i++) &#123; [self.dataList addObject:@(i).stringValue]; &#125; /// 刷新数据 /// completion返回的是BOOL值，代表是否完成刷新，用过UIView的动画不会陌生。 [self.adapter performUpdatesAnimated:YES completion:nil];&#125; 6. 效果图在刷新之后，就可以看到正常的列表样式了，如图1-2： 图 2-1 六、性能IGListKit对于collectionView列表的持有之后，对于列表的滚动和刷新操作，没有增加额外的负重，CPU和FPS保持了原生列表的性能，所以不用考虑对于性能的影响。而且在于刷新上面，IGListKit采用了差异算法，用户可以对模型自定义该算法实现。 七、高级用法 workingRangeSize的使用：列表有一个可视区域，通常系统提供的控件只支持显示的单元格才会被赋值，当使用IGListKit之后，这个workingRangeSize就提供未不可见区域向上和向下多少个区域预加载数据，如图片这些，就会在页面出来时，能够更加快速的展示给用户，而具体的大小就是你需要预加载的不可见区域的单元格数量，默认值为0. IGListDiffKit: 这个库核心是为两个集合之间的索引创建差异，IGListKit内部就是使用了这个库创建差异来高效的更新单元格。如果不使用IGListKit的时候，也可以单独使用这个库来创建差异，然后会根据算法计算出IGListIndexPathResult，拿到差异结果之后，我们就可以对列表进行增、删、移动操作了。 差异算法API：1234567NS_SWIFT_NAME(ListDiffPaths(fromSection:toSection:oldArray:newArray:option:))FOUNDATION_EXTERN IGListIndexPathResult *IGListDiffPaths(NSInteger fromSection, NSInteger toSection, NSArray&lt;id&lt;IGListDiffable&gt;&gt; *_Nullable oldArray, NSArray&lt;id&lt;IGListDiffable&gt;&gt; *_Nullable newArray, IGListDiffOption option); IGListIndexPathResult属性：12345678@property (nonatomic, copy, readonly) NSArray&lt;NSIndexPath *&gt; *inserts;@property (nonatomic, copy, readonly) NSArray&lt;NSIndexPath *&gt; *deletes;@property (nonatomic, copy, readonly) NSArray&lt;NSIndexPath *&gt; *updates;@property (nonatomic, copy, readonly) NSArray&lt;IGListMoveIndexPath *&gt; *moves; 具体使用：123456789101112131415161718- (void)_reload &#123; /// 获取数据 NSArray *oldArray = [self _oldDatas]; NSArray *newArray = [self _newDatas]; /// 计算出差异结果 IGListIndexPathResult *result = IGListDiffPaths(0, 0, oldArray, newArray, IGListDiffEquality); __weak typeof(self) weakSelf = self; /// 更新界面 [self.collectionView performBatchUpdates:^&#123; [weakSelf.collectionView deleteItemsAtIndexPaths:result.deletes]; [weakSelf.collectionView insertItemsAtIndexPaths:result.inserts]; for (IGListMoveIndexPath *p in result.moves) &#123; [weakSelf.collectionView moveItemAtIndexPath:p.from toIndexPath:p.to]; &#125; &#125; completion:^(BOOL finished) &#123; &#125;];&#125; 八、针对项目使用优缺点： 优点： 通过数据驱动列表展示，构建的单元格更加灵活，易扩展。 是一个利于组件化和列表控件复用的框架。 提供自定义工作区域的大小。 通过差异算法更新单元格，更加高效，可更具数据模型自定义差异算法。 缺点： 一个全新的框架，替换旧的系统列表控件工作量大，成本高。 所有的数据模型需要实现差异算法。 由于CollectionView已经绑定给IGListAdapter，所以客户端不应调用任何UICollectionView涉及重新加载、插入、删除或以其他方式更新单元格和索引路径的API。 在iOS 10中，引入了一个新的单元预取API，启用此功能会大大降低滚动性能，所以建议在Swift中设置isPrefetchingEnabled为NO(false)，默认值为true。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"全民Party歌词文档","slug":"工作项目/全民Party/歌词-doc","date":"2022-03-10T14:24:21.006Z","updated":"2022-03-10T14:24:21.007Z","comments":true,"path":"2022/03/10/工作项目/全民Party/歌词-doc/","link":"","permalink":"http://example.com/2022/03/10/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%85%A8%E6%B0%91Party/%E6%AD%8C%E8%AF%8D-doc/","excerpt":"","text":"作者：魏乔森 一、歌词解析流程图： 补充说明：歌词文件解析是将歌词文件解析成NSString对象，将获得的NSString对象解析成LyricInfo（歌词对象），解析分为旧歌词解析和新歌词解析，如果都没解析成功，则返回空歌词对象（解析失败），抢唱歌词解析流程只是在普通歌词解析流程中多出了空位歌词设置逻辑 相关类：LyricInfo：歌词对象 KscLineInfo：单句歌词对象 KscDecode：新歌词解析器 LyricDecorder：旧歌词解析器 类结构图： 补充说明：类结构图表示一种包含关系，并不表示唯一包含 二、歌词展示流程图： 补充说明：歌词渲染开启异步线程目的是为了控制渲染频率，目前字歌词频率为每30000ul刷新一次，其余为每100000ul刷新一次 相关类：CKScrollLyricsView：歌词展示控件 CKLrcViewConfiguration：歌词配置信息类（包含歌词显示方式，如字歌词显示还是句歌词显示，歌词字体大小等参数） CKLrcChorusRecords：歌词合唱类型切换记录类 LrcLabel：单行歌词展示控件 CKLrcViewCell：歌词展示cell CKLrcViewChorusCell：合唱歌词展示cell CKLrcViewBaseCell：歌词展示cell基类 LrcLooper：歌词渲染开启异步线程控制渲染频率工具类 类结构图： 补充说明： 歌词渲染原理：歌词显示cell内部有2个LrcLabel，有渲染颜色的LrcLabel在顶部，在未渲染的情况下，顶部的LrcLabel宽度为0，此时只显示底部的LrcLabel，所以呈现状态为未渲染状态，然后在渲染中根据时间算出应该渲染的进度，改变顶部LrcLabel的宽度，即看到歌词渲染进入效果，歌词滚动效果基于UICollectionView自带滚动效果 合唱歌词：歌词渲染逻辑上新增用户头像显示（根据合唱类型我唱，他唱，合唱分别显示我的头像，他的头像，我和他的头像）","categories":[{"name":"工作项目","slug":"工作项目","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/"},{"name":"全民Party","slug":"工作项目/全民Party","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%85%A8%E6%B0%91Party/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"作品录制文档","slug":"工作项目/全民Party/作品录制-doc","date":"2022-03-10T14:24:21.000Z","updated":"2022-03-10T14:24:21.000Z","comments":true,"path":"2022/03/10/工作项目/全民Party/作品录制-doc/","link":"","permalink":"http://example.com/2022/03/10/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%85%A8%E6%B0%91Party/%E4%BD%9C%E5%93%81%E5%BD%95%E5%88%B6-doc/","excerpt":"","text":"作者：魏乔森 总体流程图： 特别说明：以下（点唱音频/MV，快唱音频/MV，说说音频/MV，创作音频/MV，合唱)统称为心情，相关流程和弹唱分开说明一、资源准备流程1.1、心情资源准备阶段流程图： 相关类：CKFeedRecordPrepareBaseCtrl：资源准备页基类 CKFeedRecordPrepareSelectCtrl：点唱资源准备页 CKFeedRecordPrepareQuickCtrl：快唱资源准备页 CKFeedRecordPrepareTalkCtrl：说说资源准备页 CKFeedRecordPrepareCreateCtrl：创作资源准备页 CKFeedRecordPrepareChorusCtrl：合唱资源准备页 CKMVResourceDownloader：说说/快唱/创作/合唱台本，伴奏资源下载器 DownloadBeatManager：官方伴奏下载器（点唱/合唱伴奏为官方伴奏时使用此下载器下载伴奏资源） 补充说明：心情资源准备页只是从服务器请求台本或伴奏详情，不做文件下载，文件下载均在资源下载页（和录制准备页是同一个控制器，通过状态控制界面显示）下载，创作目前暂无资源下载，进入资源准备页后直接进入录制准备页 1.2、弹唱资源准备阶段流程图： 相关类：CKFeedRecordPreparePickCtrl：弹唱资源准备页 CKPlayGlobalDownloader：弹唱资源文件下载器 补充说明：弹唱准备页既请求曲谱详情，同时也下载相关资源文件（这也是和心情资源准备阶段的区别），然后进入弹唱准备页 类结构图： 二、录制流程2.1、心情录制阶段流程图： 补充说明： 录制框架启动（创作录制需同时启动科大讯飞语音识别框架）前需要指定伴奏文件路径，无伴奏文件则传空，创作语音识别文本作为编辑页使用的字幕，其余录制以资源文件中的歌词为字幕（需根据录制时长进行过滤，使用录制时间范围内的歌词），如果没有歌词，则无字幕 视频录制：框架启动是在视频框架启动后再启动音频录音框架，待2个框架均启动完成后再开始录制，录制视频的同时也录制音频 暂停回溯：暂停时整个流程依然是在录制中状态，暂停时框架停止（录音/录视频）和播放伴奏，恢复录制时向框架传入伴奏播放时间和录制开始时间后恢复框架录制，框架处理录制音频补齐，截取操作（暂停回溯功能只在合唱，快唱，点唱中歌词文件和伴奏文件合格才有） 资源补充说明：快唱/说说资源是台本资源，其内部包括了专属伴奏，专属背景，歌词，台本资源，创作目前资源只有在录制前用户选择的伴奏资源，如果未选择，则无资源，点唱资源主要是官方伴奏资源，如果是清唱或导入伴奏则无所需下载资源，合唱分为快唱合唱和点唱合唱，如果是快唱合唱则下载对应快唱台本资源，点唱合唱则下载对应官方伴奏资源，合唱除以上资源还包括合唱作品用户干声文件资源 异常操作：退后台，拔耳机等操作在有暂停回溯功能时暂停录制，否则直接停止录制流程 相关类：CKMVEditSettingManager（核心类，单例）：该类在整个心情流程中使用，该类有整个制作流程所需大部分参数，在整个流程结束后需要重置相关参数 CKMVBaseViewCtrl：作品制作流程中的所有控制器基类 CKMVSingRecordCtrl：快唱资源下载页，准备页，录制页（同一页面通过CKMVEditSettingManager中录制状态控制界面显示，下同） CKMVSpeakRecordCtrl：说说资源下载页，准备页，录制页 CKMVCreateRecordCtrl：创作资源下载页，准备页，录制页 CKMVChorusRecordCtrl：合唱资源下载页，准备页，录制页 CKSelectSongsRecordCtrl：点唱资源下载页，准备页，录制页 CKRoomTuningViewCtrl：点唱，快唱，合唱调音面板（设置录制伴奏，人声音量等） CKMVRecordVoiceCheckCtrl：说说，创作调音面板（设置录制伴奏，人声音量） CKMVStartRecordBottomView：快唱/说说/创作/合唱底部按钮控件（录制按钮，暂停按钮，调音等） CKMVSelectSongsBottomView：点唱底部按钮控件（录制按钮，调音等） CKMVRecordContentView：说说/快唱中间歌词，进音灯UI控件（通过CKMVEditSettingManager中录制状态控制不同显示） CKMVAudioNameContentView：说说/创作选择伴奏名称跑马灯控件 CKMVMusicSelectView：说说/创作选择伴奏控件（此处选择的伴奏会作为录制时播放的伴奏） CKMVResourceClassify：选择伴奏页分类对象 CKMVResource：整个心情流程中伴奏和背景图资源对象 CKMVScenario：台本对象（其内部包含伴奏文件，歌词文件，背景资源文件） MCGraphicsVideo：MV录制框架类 MCAudioRecorder：音频录制框架类 IFlySpeechRecognizer：科大讯飞语音识别框架类 StreamRecognizer：科大讯飞语音识别中间类（内部封装IFlySpeechRecognizer） CKVideoFabricator：说说/快唱/创作 MV制作类（内部封装CKVideoFabricator） SpeechRecognizer：心情录制框架封装类（内部封装了StreamRecognizer，CKVideoFabricator，MCAudioRecorder，目前只有在说说默认录制流程和创作才需要语音识别），使用此类启动和停止录音框架 RecordScoreHelper：评分辅助类，处理框架回调，协助对应控件做对应的动画 CKWorkScoreProgressView：评分等级进度控件 CKWorkMidiView：midi显示控件（内部包含了评分相关动画显示） 2.2、弹唱录制阶段流程图： 补充说明：弹唱录制中会有练习框架/录音框架2个框架，在准备页中播放和弦等相关音频资源会使用练习框架进行播放，录制中是使用录音框架播放 异常操作：退后台，拔耳机等异常操作直接停止录制流程 相关类：MCBeatPractise：弹唱练习框架对象 MCBeatRecorder：弹唱录制框架对象 CKPlayRecordModel：弹唱-录制页model，内部封装MCBeatPractise和MCBeatRecorder以及录制需要的相关的参数 CKPlayRecordViewCtrl ：弹唱准备页，录制页（通过CKPlayRecordModel的isRecording来控制显示准备页还是录制中） CKPlayTone：弹唱-音调基类 CKPlayLyricTone：弹唱歌词中的音调对象，继承于CKPlayTone CKPlayFingering：弹唱指法对象 CKPlayTimbre：音色对象（包含N个CKPlayFingering对象） CKPlayInstrument：乐器对象（包含N个CKPlayTimbre对象） CKPlayLyricView：弹唱歌词控件 CKPlayAtmosphereView：弹奏和弦点击后屏幕2侧的氛围动画控件 PlayScrollView：乐器切换控件（切换后会触发下载操作） CKPlayInstrumentDownloadCoverView：乐器下载时上面的蒙层 CKPlayRecordBottomView：底部录制等按钮控件 CKPlayToneTuningPanel：弹唱调音面板（设置录制录制伴奏，人声音量） CKPlayInstrumentPanel：乐器面板（乐器选择面板，选择不同乐器，会有不同和弦点击音效） CKPlayPickReplayViewCtrl：弹唱回放页（推荐的用户发布的弹唱效果展示） CKPlayChordView：和弦组控件，点击会播放对应和弦（录制页点击播放和弦，编辑页会展示对应和弦点击动画，发布页会生成对应涂层文件传入框架合成相关和弦点击动画） CKPlayPercussionView：打击控件，点击会播放打击音效 类结构图： 三、编辑流程3.1、心情编辑阶段流程图： 补充说明：编辑页就是作品录制后播放效果的预览页，用户可以在此处做作品相关编辑操作（如加贴图，编辑字幕，切换背景显示等）并查看编辑后的效果，此效果即为作品发布后的效果，所有编辑效果均是UI操作，所有编辑效果使用的资源数据（例：贴图资源对象，贴图缩放比例，旋转角度等）会使用CKMVEditSettingManager类中对应数据存储后在发布页使用合成完整作品 相关类：CKMVEditViewCtrl：心情编辑页 CKMVEditPreView：心情预览播放控件（内部封装了音频的预览视图和mv的视频播放视图） CKMVSubtitleEditView：预览区域字幕显示编辑控件 CKMVEditPlayView：播放控制控件（内部封装了播放器） CKMVEditActionView：底部功能控件（选择弹起字幕面板，背景图面板等对应面板） CKMVFilmsTitlePanel：片头选择面板控件 CKMVSubtitleV2Panel：字幕面板控件（可添加，删除，编辑字幕） CKMVBackViewPanel：背景图面板控件（可以选择官方背景或是自定义背景，自定义背景会根据录制时长设置最大显示数量） CKMVAudioPanel：伴奏面板控件（此处伴奏会作为编辑预览播放的伴奏，未选择则为录制页或草稿箱保存的伴奏） CKMVVoicePanel：调音面板控件（设置预览播放伴奏，人声音量等相关参数） CKMVStickerPanel：贴图面板控件（选择的贴图会以CKMVStickerOperateView对象添加到CKMVEditPreView上进行展示） CKMVStickerOperateView：预览区贴图编辑控件（有个数限制，目前最多为为10，有旋转缩放功能） CKFeedInfo：草稿箱作品对象（作品保存草稿后相关参数会以此对象对应参数存储） MCChorusPreviewer：合唱预览播放器 MCAudioPreviewer：点唱，快唱，说说，创作预览音频播放器 CKGrabSongPoolPlayer：MV录制时预览页视频播放器 CKMVEditScoreView：顶部得分控件（等分等级展示） CKWorkScoreView：评分结果页（评分，等级动效展示） CKDraftsManager：草稿箱管理类（使用此类进行心情作品保存，删除） 3.2、弹唱编辑阶段补充说明：弹唱编辑整体流程和心情音频编辑流程大体一样（资源编辑面板只有背景图，调音，贴图，存储编辑数据使用CKPlayModel类），可参考上面心情编辑流程图 相关类：CKPlayEditViewCtrl：编辑页 CKPlayEditPreView：预览播放控件 CKPlayEditContentView：预览区和弦和歌词显示控件 CKPlayEditActionView：底部功能控件（同心情底部功能控件功能） CKPlayBgViewPanel：背景图面板控件（同心情背景图面板功能） CKPlayTuneViewPanel：调音面板控件（同心情调音面板功能） CKPlayStickerViewPanel：贴图面板控件（同心情贴图面板功能） CKPlayStickerOperateView：预览区贴图编辑控件（同心情预览区贴图编辑控件功能） CKPlayModel：弹唱通用数据模型，保存弹唱相关参数，在发布页会使用相关参数生成作品 MCBeatPreviewer：弹唱预览播放器 类结构图： 四、发布流程4.1、心情发布阶段流程图： 补充说明：发布页即是将编辑页编辑后的作品相关资源数据在此处通过框架进行音，视频合成，最终将编辑页相关数据合成一个和编辑页预览效果一致的视频后发布（文件上传使用七牛） 相关类：CKMVReleaseCtrl：心情发布页 CKShareSaveVideoToLocalViewCtrl：发布进度loading页 CKMVReleaseFeaturesView：发布页功能控件 CKMVReleaseFeatureModel：功能模型类 CKMVReleaseHeaderView：封面控件 MCAudioRender：音频合成器 MCChorusRender：合唱音频合成器 MKVideoRender：MV录制时使用 MKImagesRender：背景图是自定义图或静态图时使用 MKGifRender：背景图是GIF时使用 补充说明：以上3个render会根据类型不同选择某一个作为合成视频所需的render MKRenderLayer：贴图或字幕图片使用（最终通过相关API加在合成视频的render上） MKRenderFadeAnimate：片头使用（最终通过相关API加在合成视频的render中） MKExporter：视频合成器（通过合成视频的render来生成视频） MKWaterRender：保存视频给视频添加水印使用 MCFileLinker：音频文件补齐工具类 CKFeedUploadTool（单例）：作品发布工具类，其内部封装了文件上传，与服务器接口交互功能，作品上传状态，上传进度也通过其参数回调 4.2、弹唱发布流程：补充说明：弹唱发布流程和心情发布流程大体一样，在制作音频和视频部分会有部分区别，流程可参考心情发布流程图 相关类：CKMVReleaseCtrlV2：弹唱发布页 MCBeatRender：弹唱音频合成器 视频合成相关类同心情制作视频合成相关类 类结构图：","categories":[{"name":"工作项目","slug":"工作项目","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/"},{"name":"全民Party","slug":"工作项目/全民Party","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%85%A8%E6%B0%91Party/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"作品互动消息","slug":"工作项目/全民Party/作品互动消息-doc","date":"2022-03-10T14:24:20.999Z","updated":"2022-03-10T14:24:21.000Z","comments":true,"path":"2022/03/10/工作项目/全民Party/作品互动消息-doc/","link":"","permalink":"http://example.com/2022/03/10/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%85%A8%E6%B0%91Party/%E4%BD%9C%E5%93%81%E4%BA%92%E5%8A%A8%E6%B6%88%E6%81%AF-doc/","excerpt":"","text":"作者：熊甫荣 本文档主要梳理全民Party中 作品点赞、评论以及合唱消息功能开发的主要逻辑，今后在开发类似功能时可参照此文档。主要功能包括消息构造、消息收发、消息监听、消息存储。 整体结构 相关类介绍作品消息核心类： CKIMFeedLikeMessage: 作品点赞消息模型，CKIMMessage的子类; CKIMFeedCommentMessage: 作品评论消息模型，CKIMMessage的子类; CKIMFeedChorusMessage: 作品合唱消息模型，CKIMMessage的子类; CKFeedSendMessageManager: 作品消息发送管理类，通过CKIMSendMessageHelper来发送具体消息; 1234567891011121314151617181920212223242526272829303132333435363738/** 发送点赞消息 @param feedModel 作品 */+ (void)sendLikeMessageWithFeedModel:(CKFeedCardModel *)feedModel likeNotice:(NSInteger)likeNotice;/** 发送评论消息 @param feedModel 作品 @param comment 发送的评论 @param reply 回复的评论 @param replySuper 顶级评论 @param feedNoticeSetModel 接收方是否开启通知 */+ (void)sendCommentMessageWithFeedModel:(CKFeedCardModel *)feedModel comment:(CKFeedCommentReplyModel *)comment reply:(nullable CKFeedCommentReplyModel *)reply replySuper:(nullable CKFeedCommentReplyModel *)replySuper feedNoticeSetModel:(CKFeedNoticeSetModel *)feedNoticeSetModel;/** 发送合唱消息 @param userId 原作品用户ID @param originalId 原作品Id @param chorusName 作品名称 @param chorusId 当前合唱作品ID @param cover 作品首帧缩略图 */+ (void)sendChorusMessageToUserId:(NSString*)userId originalId:(NSString *)originalId chorusName:(NSString *)chorusName chorusId:(NSString *)chorusId cover:(NSString *)cover chorusNotice:(NSInteger)chorusNotice; CKIMSendMessageHelper: 消息发送工具类; 1234567891011121314151617181920212223242526272829303132/** 发送作品点赞消息 @param userid 接收消息的用户 @param buildMessageParmam 构建作品消息参数 @param needNotice 是否需要桌面通知 */+ (void)sendLikeMessageToUserID:(NSString *)userid buildMessageParmam:(void(^)(CKIMFeedLikeMessage * message))buildMessageParmam needNotice:(BOOL)needNotice; /** 发送评论消息 @param userid 接收消息的用户 @param buildMessageParmam 构建评论消息参数 @param needNotice 是否需要桌面通知 */+ (void)sendCommentMessageToUserID:(NSString *)userid buildMessageParmam:(void(^)(CKIMFeedCommentMessage * message))buildMessageParmam needNotice:(BOOL)needNotice;/** 发送作品合唱消息 @param userid 接收消息的用户 @param buildMessageParmam 构建作品消息参数 @param needNotice 是否需要桌面通知 */+ (void)sendChorusMessageToUserID:(NSString *)userid buildMessageParmam:(void(^)(CKIMFeedChorusMessage * message))buildMessageParmam needNotice:(BOOL)needNotice; CKFeedDBManager: 本地作品相关消息存储管理类; 作品点赞 12345678910111213141516171819202122232425/** 获取全部点赞 */+ (NSArray *)fetchAllLikes;+ (NSArray *)fetchLikesWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime;/** 获取点赞 @param uniquelyId 查询数据画最后一条的唯一标示 @param count 每页个数 @return &lt;#return value description#&gt; */+ (NSArray *)fetchLikesWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime count:(NSInteger)count;/** 所有点赞置为已读 */+ (BOOL)allRead4LikesByCreateTime:(nullable NSString *)createTime;///**// 点赞未读数// */+ (NSInteger)unreadCount4Likes;/** 删除多余的点赞数据 */+ (BOOL)delLikesDataUnnecessary; 作品评论 1234567891011121314151617181920212223242526+ (NSArray *)fetchAllComments;+ (NSArray *)fetchAllCommentsNeedTransform:(BOOL)needTransform;+ (NSArray *)fetchCommentsWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime;+ (NSArray *)fetchCommentsWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime needTransform:(BOOL)needTransform;+ (NSArray *)fetchCommentsWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime count:(NSInteger)count;/** 获取评论 @param uniquelyId 查询数据画最后一条的唯一标示 @param count 分页数据 @param needTransform 获取出的数据转化为自定义model @return &lt;#return value description#&gt; */+ (NSArray *)fetchCommentsWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime count:(NSInteger)count needTransform:(BOOL)needTransform;/** 所有评论置为已读 */+ (BOOL)allRead4CommentsByCreateTime:(nullable NSString *)createTime;///**// 评论未读数// */+ (NSInteger)unreadCount4Comments;/** 删除多余的评论数据 */+ (BOOL)delCommentsDataUnnecessary; 作品合唱 12345678910111213141516171819202122232425/** 获取全部合唱 */+ (NSArray *)fetchAllChorus;+ (NSArray *)fetchChorusWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime;/** 获取合唱 @param uniquelyId 查询数据画最后一条的唯一标示 @param count 每页个数 @return &lt;#return value description#&gt; */+ (NSArray *)fetchChorusWithUniquelyId:(nullable NSString *)uniquelyId createTime:(nullable NSString *)createTime count:(NSInteger)count;/** 所有合唱置为已读 */+ (BOOL)allRead4ChorusByCreateTime:(nullable NSString *)createTime;///**// 合唱未读数// */+ (NSInteger)unreadCount4Chorus;/** 删除多余的合唱数据 */+ (BOOL)delChorusDataUnnecessary; 其它 12345678910111213/** 数据库更新 */+ (void)checkUpdate;/** 插入一条数据 */+ (BOOL)insert:(id)message;/** 插入多条数据 */+ (void)insertArr:(NSArray *)messages; 在CKMainViewCtrl中监听点赞、评论、合唱消息： 12345678910111213141516- (void)__bindRAC &#123; @weakify(self) ... //v2.3.0 --收到点赞和评论消息 [CKIMContextObserve(feedLikeMessage) subscribeNext:^(id x) &#123; [CKFeedDBManager insert:x]; &#125;]; [CKIMContextObserve(feedCommentMessage) subscribeNext:^(id x) &#123; [CKFeedDBManager insert:x]; &#125;]; //v2.8.0 --收到合唱消息 [CKIMContextObserve(feedChorusMessage) subscribeNext:^(id x) &#123; [CKFeedDBManager insert:x]; &#125;]; ...&#125; 数据库设计 每个登陆用户(作品收到过点赞、评论、合唱)有一个数据库，数据库中存在1个用户信息表、1个作品点赞表、1个作品评论表、1个作品合唱表。 含义 名称 数据库 feedlib 用户信息表 kCKFeedUserTable_ 作品点赞表 kCKFeedLikeTable_@(userid) 作品评论表 kCKFeedCommentTable_@(userid) 作品合唱表 kCKFeedChorusTable_@(userid) 表结构kCKFeedUserTable_ 列名 含义 userId 用户id(唯一) user 用户基本信息json字符串 kCKFeedLikeTable_@(userid) 列名 含义 messageId 消息id(唯一) feedId 作品id cover 作品封面图url likeUserId 点赞用户id likeUserName 点赞用户昵称 likeUserAvatar 点赞用户头像 createTime 点赞时间 isRead 是否已读 isVIP 是否vip needShowVipFlag 是否显示vip标识 commentId 点赞评论id kCKFeedCommentTable_@(userid) 列名 含义 messageId 消息id(唯一) feedId 作品id cover 作品封面图url sendToFeedUser 是否给作品作者发 commentUserId 评论用户id commentUserName 评论用户昵称 commentUserAvatar 评论用户头像 commentId 评论id commentContent 评论内容 replyUserId 回复评论用户id replyUserName 回复评论用户昵称 replyUserAvatar 回复评论用户头像 replyCommentId 回复评论id replyCommentContent 回复评论内容 createTime 评论时间 isRead 是否已读 isVIP 是否vip needShowVipFlag 是否显示vip标识 kCKFeedChorusTable_@(userid) 列名 含义 messageId 消息id(唯一) originalId 原作品id cover 合唱作品封面 chorusId 合唱作品id chorusName 合唱作品名称 chorusUserId 合唱用户id chorusUserName 合唱用户昵称 chorusUserAvatar 合唱用户头像 createTime 合唱时间 isRead 是否已读 isVIP 是否vip needShowVipFlag 是否显示vip标识","categories":[{"name":"工作项目","slug":"工作项目","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/"},{"name":"全民Party","slug":"工作项目/全民Party","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%85%A8%E6%B0%91Party/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Siwft规范","slug":"基础规范/Swift规范-doc","date":"2022-03-10T14:24:20.998Z","updated":"2022-03-10T14:27:00.636Z","comments":true,"path":"2022/03/10/基础规范/Swift规范-doc/","link":"","permalink":"http://example.com/2022/03/10/%E5%9F%BA%E7%A1%80%E8%A7%84%E8%8C%83/Swift%E8%A7%84%E8%8C%83-doc/","excerpt":"","text":"This is an example image","categories":[{"name":"基础规范","slug":"基础规范","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"测试一哈哈","slug":"基础规范/基础规范-doc","date":"2022-03-10T14:24:20.998Z","updated":"2022-03-10T14:24:20.998Z","comments":true,"path":"2022/03/10/基础规范/基础规范-doc/","link":"","permalink":"http://example.com/2022/03/10/%E5%9F%BA%E7%A1%80%E8%A7%84%E8%8C%83/%E5%9F%BA%E7%A1%80%E8%A7%84%E8%8C%83-doc/","excerpt":"","text":"This is an example image","categories":[{"name":"基础规范","slug":"基础规范","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"KaraParty歌词文档","slug":"工作项目/Karaparty/歌词-doc","date":"2022-03-10T14:24:20.998Z","updated":"2022-03-10T14:24:20.998Z","comments":true,"path":"2022/03/10/工作项目/Karaparty/歌词-doc/","link":"","permalink":"http://example.com/2022/03/10/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/Karaparty/%E6%AD%8C%E8%AF%8D-doc/","excerpt":"","text":"作者：：魏乔森 一、歌词解析流程图： 补充说明：歌词文件解析分为加密和非加密2种情况，最终结果都是将歌词文件解析成NSDictionary对象，将获得的NSDictionary对象解析成PhoneticLyricInfo（注音歌词对象）时包含歌词时间校验（如果是非纯文本歌词且歌词结束时间小于歌词开始时间，直接解析失败返回空歌词对象），抢唱歌词解析流程只是在普通歌词解析流程中多出了空位歌词解析逻辑 相关类：LyricInfo：歌词基类对象 PhoneticLyricInfo：注音歌词对象，继承于LyricInfo KscLineInfo：单句歌词对象 KscWordInfo：单个字对象（单个字是指包含注音的一个词组） KscPhoneticWordInfo：注音歌词对象 类结构图： 补充说明：类结构图只是表示一种包含关系，并不表示唯一包含 二、歌词展示流程图： 补充说明：歌词渲染开启异步线程目的是为了控制渲染频率，目前字歌词频率为每30000ul刷新一次，其余为每100000ul刷新一次 相关类：CKScrollLyricsView：歌词展示控件 CKLrcViewConfiguration：歌词配置信息类（包含歌词显示方式，如字歌词显示还是句歌词显示，歌词字体大小等参数） CKLrcChorusRecords：歌词合唱类型切换记录类 LrcLabel：单行歌词展示控件（非注音歌词） CKLrcViewCell：句歌词展示cell（非注音歌词，内部包含LrcLabel） CKPhoneticLineView：注音歌词展示控件 CKPhoneticLrcViewCell：字歌词展示cell（内部包含CKPhoneticLineView） CKChorusLrcViewCell：合唱句歌词展示cell CKPhoneticLrcChorusViewCell：合唱注音歌词展示cell CKLrcViewBaseCell：歌词展示cell基类 类结构图： 补充说明： 歌词渲染原理： 非注音歌词：歌词显示cell内部有2个LrcLabel，有渲染颜色的LrcLabel在顶部，在未渲染的情况下，顶部的LrcLabel宽度为0，此时只显示底部的LrcLabel，所以呈现状态为未渲染状态，然后在渲染中根据时间算出应该渲染的进度，改变顶部LrcLabel的宽度，即看到歌词渲染进入效果，歌词滚动效果基于UICollectionView自带滚动效果 注音歌词：渲染原理同非注音歌词，只是展示控件为CKPhoneticLineView，其内部显示是将注音词组分成多个CKPhoneticWordView控件拼接展示，CKPhoneticWordView并未暴露，在CKPhoneticLineView内部定义 合唱歌词：歌词渲染逻辑上新增用户头像显示（根据合唱类型我唱，他唱，合唱分别显示我的头像，他的头像，我和他的头像）","categories":[{"name":"工作项目","slug":"工作项目","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/"},{"name":"Karaparty","slug":"工作项目/Karaparty","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/Karaparty/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]}],"categories":[{"name":"生活学习","slug":"生活学习","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"工作项目","slug":"工作项目","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/"},{"name":"全民Party","slug":"工作项目/全民Party","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/%E5%85%A8%E6%B0%91Party/"},{"name":"基础规范","slug":"基础规范","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E8%A7%84%E8%8C%83/"},{"name":"Karaparty","slug":"工作项目/Karaparty","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C%E9%A1%B9%E7%9B%AE/Karaparty/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]}